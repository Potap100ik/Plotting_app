#pragma once
#pragma warning(disable : 4996)

#include <Windows.h>
#include <tchar.h>
#include <cmath>
#include <string>
#include <vector>
#include <gdiplus.h>
#include <array>
#include "str_to_double.h"
#define MAX_LOADSTRING 100
#define edit_otst1 60
#define edit_otst2 20
using namespace Gdiplus;

HWND
hWnd_main{},
hWnd_plot{},
hWndButton_enter{},
hWndButton_clearPlot{},
hWndButton_clearEdit{},
hWndEdit_base{},
hWndEdit_A{},
hWndEdit_B{},
hWndEdit_H{};



enum CTL_ID {
	HWNDBUTTON_ENTER,
	HWNDBUTTON_CLEARPLOT,
	HWNDBUTTON_CLEAREDIT,
	HWNDEDIT_BASE,
	HWNDEDIT_A,
	HWNDEDIT_B,
	HWNDEDIT_H
};
TCHAR Win_Plot_NAME[MAX_LOADSTRING] = _T("PlotWindow");


extern HINSTANCE hInst;
int sx{}, sy{};
int sx_center{}, sy_center{};

std::vector<POINT> myvec_xy{};
struct Pointer {
	double x, y;
};
std::vector<Pointer> myvec_copy{};
//std::vector<double>::iterator it{};
double A = -10, B = 10, H = 0.1, C = max(abs(A), abs(B));/*10*/// bord_setka = 250;
double Ar = -10, Br = 10, Hr = 0.1, Cr = max(abs(Ar), abs(Br))/*10*/;

//double kxy_setka = bord_setka / C;//25 - пиксел/у.е - от нуля до границы............................................
///double size_setka = 1 / kxy_setka;//0.04 у.е/пиксел.......................................
//double hxy_setka = kxy_setka * H;//....................................................

int h_setka = 10, h5_setka = h_setka * 5;
double u5_setka = C/5;//у.е на 5 сеточных клеток
double kxy_setka = h5_setka / u5_setka;


//процедуры классов
LRESULT CALLBACK WinProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK Win_Plot(HWND, UINT, WPARAM, LPARAM);

//вспомогашки
ATOM MyRegisterChildClass();
LPVOID CreateControls(HWND);
void transform(HDC& hdc);
double what_a_fk_its_too_late(double);


double what_a_fk_its_too_late(double include_something)
{
	double u;
	double c1 = include_something;
	int n;
	int k = 0;
	if (c1 >= 1) {

		do {
			n = c1 / 10;
			c1 /= 10;
			k++;
		} while (n != 0);
		n = round(c1 * 10); k--;
	}
	else if (c1 < 1) {

		do {
			n = c1 * 10;
			c1 *= 10;
			k--;
		} while (n == 0);
		n = round(c1);
	}
	if (n <= 2) {
		u = n * pow(10, k);
	}
	else if (n <= 5) {
		u = 5 * pow(10, k);
	}
	else {
		u = 1 * pow(10, k + 1);
	}
	return u;
}
LPVOID CreateControls(HWND hWnd)
{
	hWndButton_enter = CreateWindowEx(
		0,
		L"BUTTON",
		L"Построить график",
		WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE,
		60, 120, 240, 30,
		hWnd,
		reinterpret_cast<HMENU> (CTL_ID::HWNDBUTTON_ENTER),
		nullptr, nullptr);
	if (!hWndButton_enter)
		MessageBox(NULL, _T("hWndButton_enter"), _T("Ошибка"), MB_OK);

	hWndButton_clearPlot = CreateWindowEx(
		0,
		L"BUTTON",
		L"Убрать данные графика",
		WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE,
		edit_otst1, 160, 240, 30,
		hWnd,
		reinterpret_cast<HMENU> (CTL_ID::HWNDBUTTON_CLEARPLOT),
		nullptr, nullptr);
	if (!hWndButton_clearPlot)
		MessageBox(NULL, _T("hWndButton_clearPlot"), _T("Ошибка"), MB_OK);

	hWndButton_clearEdit = CreateWindowEx(
		0,
		L"BUTTON",
		L"Убрать данные полей",
		WS_CHILD | BS_PUSHBUTTON | WS_VISIBLE,
		edit_otst1, 200, 240, 30,
		hWnd,
		reinterpret_cast<HMENU> (CTL_ID::HWNDBUTTON_CLEAREDIT),
		nullptr, nullptr);
	if (!hWndButton_clearEdit)
		MessageBox(NULL, _T("hWndButton_clearEdit"), _T("Ошибка"), MB_OK);



	hWndEdit_base = CreateWindowEx(
		WS_EX_CLIENTEDGE,
		L"EDIT",
		L"sin(x)/x",
		WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL,
		edit_otst1, 40, 240, 30,
		hWnd,
		reinterpret_cast<HMENU>(CTL_ID::HWNDEDIT_BASE),
		nullptr, nullptr);
	if (!hWndEdit_base)
		MessageBox(NULL, _T("hWndEdit_base"), _T("Ошибка"), MB_OK);

	hWndEdit_A = CreateWindowEx(
		WS_EX_CLIENTEDGE,
		L"EDIT",
		L"-10",
		WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL,
		edit_otst1, 80, 40, 30,
		hWnd,
		reinterpret_cast<HMENU>(CTL_ID::HWNDEDIT_A),
		nullptr, nullptr);
	if (!hWndEdit_A)
		MessageBox(NULL, _T("hWndEdit_A"), _T("Ошибка"), MB_OK);
	hWndEdit_B = CreateWindowEx(
		WS_EX_CLIENTEDGE,
		L"EDIT",
		L"10",
		WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL,
		edit_otst1 + 80, 80, 60, 30,
		hWnd,
		reinterpret_cast<HMENU>(CTL_ID::HWNDEDIT_B),
		nullptr, nullptr);
	if (!hWndEdit_B)
		MessageBox(NULL, _T("hWndEdit_B"), _T("Ошибка"), MB_OK);

	hWndEdit_H = CreateWindowEx(
		WS_EX_CLIENTEDGE,
		L"EDIT",
		L"0.1",
		WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL,
		edit_otst1 + 180, 80, 60, 30,
		hWnd,
		reinterpret_cast<HMENU>(CTL_ID::HWNDEDIT_H),
		nullptr, nullptr);
	if (!hWndEdit_H)
		MessageBox(NULL, _T("hWndEdit_H"), _T("Ошибка"), MB_OK);


	CreateWindowEx(0, L"STATIC", L"Поле для уравнения", WS_CHILD | SS_LEFT | WS_VISIBLE, edit_otst2, 15, 280, 20, hWnd, nullptr, nullptr, nullptr);
	CreateWindowEx(0, L"STATIC", L"F(x) = ", WS_CHILD | SS_LEFT | WS_VISIBLE, edit_otst2, 42, 40, 20, hWnd, nullptr, nullptr, nullptr);
	CreateWindowEx(0, L"STATIC", L"A = ", WS_CHILD | SS_LEFT | WS_VISIBLE, edit_otst2, 82, 40, 20, hWnd, nullptr, nullptr, nullptr);
	CreateWindowEx(0, L"STATIC", L"B = ", WS_CHILD | SS_LEFT | WS_VISIBLE, edit_otst1 + 40, 82, 40, 20, hWnd, nullptr, nullptr, nullptr);
	CreateWindowEx(0, L"STATIC", L"C = ", WS_CHILD | SS_LEFT | WS_VISIBLE, edit_otst1 + 140, 82, 40, 20, hWnd, nullptr, nullptr, nullptr);

	return 0;
}
ATOM MyRegisterChildClass()
{
	WNDCLASSEX wcex{};
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.lpszClassName = Win_Plot_NAME;
	wcex.lpfnWndProc = Win_Plot;
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.hInstance = hInst;
	return RegisterClassEx(&wcex);
}
LRESULT CALLBACK WinProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM	lParam)
{

	switch (message)
	{
	case WM_CREATE:
		//CreateControls();
		if (!MyRegisterChildClass())
			MessageBox(NULL, _T("НЕ ВЫШЕЛ ГРАФИК ПОГУЛЯТЬ"), _T("Ошибка"), MB_OK);
		hWnd_plot = CreateWindow(
			Win_Plot_NAME,
			NULL,
			WS_CHILD |
			WS_DLGFRAME | //запрет на изменение размеров дочернего окна
			WS_VISIBLE,
			0, 0, 0, 0,
			hWnd,
			NULL,
			hInst,
			NULL);
		break;
	case WM_SIZE:

		MoveWindow(hWnd_plot, 400, 0, LOWORD(lParam) - 405, HIWORD(lParam)-5, 1);
		sx = LOWORD(lParam) - 405;
		sy = HIWORD(lParam) - 5;
		sx_center = sx / 2;
		sy_center = sy / 2;
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case 	HWNDBUTTON_ENTER:
			try
			{
				if (!myvec_xy.empty())
				{
					myvec_xy.clear();
					myvec_copy.clear();
				}
				myvec_xy.reserve((int)(Br - Ar) / Hr + 1);//+1 - а оно вообше надо?
				myvec_copy.reserve((int)(Br - Ar) / Hr + 1);//+1 - а оно вообше надо?
				std::wstring text{};
				GetWindowText(hWndEdit_base, &text[0], MAX_PATH);
				text.erase(remove(begin(text), end(text), 0), end(text));

				/*if (text.empty())
				{
					MessageBox(hWnd, L"Введите число!", L"Информация", MB_ICONINFORMATION | MB_OK);
					break;
				}*/
				//переводим полученное сообщение из юникода в аски
				//std::wstring stemp = std::wstring(text.begin(), text.end());
				LPCWSTR sw = text.c_str();
				LPCWSTR LPWSTR_TMP = sw;
				DWORD iSizeStr = wcslen(LPWSTR_TMP) + 1;
				LPSTR lpStrTmp = (PCHAR)calloc(iSizeStr, sizeof(CHAR));
				DWORD eResult = WideCharToMultiByte(
					CP_ACP,
					WC_NO_BEST_FIT_CHARS,
					LPWSTR_TMP,
					INFINITE,
					lpStrTmp,
					iSizeStr,
					NULL,
					NULL);

				POINT point;
				Pointer pt;
				for (double x = Ar; x < Br; x += Hr) {
					point.x = pt.x =  x;
					point.y = pt.y =  Function_Count(lpStrTmp, &x);
					myvec_copy.push_back(pt);
					myvec_xy.push_back({});
				}
				
				for (int i = 0; i < myvec_copy.size(); i++)
				{

					myvec_xy[i].x = myvec_copy[i].x * kxy_setka;
					myvec_xy[i].y = myvec_copy[i].y * kxy_setka;
				}

				InvalidateRect(hWnd, NULL, TRUE);
			}
			catch (...)
			{
				MessageBox(NULL, L"Число превышает 2 байта!", L"Предупреждение", MB_ICONWARNING | MB_OK);
			}
			break;
		case	HWNDBUTTON_CLEARPLOT:
			if (!myvec_xy.empty())
			{
				myvec_xy.clear();
				myvec_copy.clear();
			}
			h_setka = 10;
			h5_setka = 50;
			u5_setka = C / 5;
			InvalidateRect(hWnd, NULL, TRUE);
			break;
		case HWNDBUTTON_CLEAREDIT:
			MessageBox(NULL, _T("НА РАБОТУ"), _T("Ошибка"), MB_OK);
			break;
		}
		break;
	case WM_DESTROY: PostQuitMessage(0); break;
	default: return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

LRESULT CALLBACK Win_Plot(HWND hWnd, UINT message, WPARAM wParam, LPARAM	lParam)
{
	PAINTSTRUCT  ps;
	Pen* myPen;
	Graphics* myGraphics;
	HDC hdc{};
	HBRUSH hBrush = CreateSolidBrush(RGB(0, 0, 255));;
	RECT rt = { 0, 0, 10, 100 };
	HRGN hRgn;
	HFONT hFont1{};
	HPEN hpen_setk1, hpen_setk2, hpen_black, hpen_plot1;
	//double x, y;

	static POINT Prev_mouse_point{};
	static BOOL Flag_for_mouse = FALSE;

	int x_edgelineR, y_edgelineT, x_edgelineL, y_edgelineB;
	int xr, xl, yt, yb;
	double kxy;
	int zerocount;
	double ux, uy;
	TCHAR s[20];
	switch (message)
	{
	case WM_CREATE:
	{
		hpen_setk1 = CreatePen(PS_SOLID, 1, RGB(204, 204, 204));
		hpen_setk2 = CreatePen(PS_SOLID, 1, RGB(150, 150, 150));
		hpen_plot1 = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
		hpen_black = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
		hFont1 = CreateFont(10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
			DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, _T("Arial"));
	}
	break;
	case WM_LBUTTONDOWN:
		Flag_for_mouse = TRUE;
		Prev_mouse_point.x = LOWORD(lParam);
		Prev_mouse_point.y = HIWORD(lParam);

		break;
	case WM_LBUTTONDBLCLK:
		InvalidateRect(hWnd, NULL, TRUE);
		break;
	case WM_MOUSEMOVE:
		if (Flag_for_mouse)
		{
			hdc = GetDC(hWnd);
			myGraphics = new Graphics(hdc);
			myPen = new Pen(Color(200, 255, 0, 0), 3);

			int x = LOWORD(lParam);
			int y = HIWORD(lParam);

			sx_center += x - Prev_mouse_point.x;
			sy_center += y - Prev_mouse_point.y;

			//myGraphics->DrawLine(myPen, Prev_mouse_point.x, Prev_mouse_point.y, x, y);

			Prev_mouse_point.x = x;
			Prev_mouse_point.y = y;

			delete myGraphics;
			delete myPen;
			EndPaint(hWnd, &ps);
			InvalidateRect(hWnd, NULL, TRUE);
		}
		return 0L;
	case WM_LBUTTONUP:
		Flag_for_mouse = FALSE;
		return 0L;
	case WM_MOUSEWHEEL:


		h_setka += GET_WHEEL_DELTA_WPARAM(wParam) / 120;


		if (h_setka <= 3)
			h_setka = 3;
		else if (h_setka >= 20)
		{
			h_setka = 10;
			u5_setka = what_a_fk_its_too_late(u5_setka / 2.1);
		}
		else if (h_setka < 10)
		{
			h_setka = 19;
			u5_setka = what_a_fk_its_too_late(u5_setka*2.1);

		}
		h5_setka = h_setka * 5;
		kxy_setka = h5_setka / u5_setka;


		

		for (int i = 0; i < myvec_xy.size(); i++)
		{
			myvec_xy[i].x = myvec_copy[i].x * kxy_setka;
			myvec_xy[i].y = myvec_copy[i].y * kxy_setka;
		}
		InvalidateRect(hWnd, NULL, TRUE);
		break;
	case WM_SIZE:
		sx = LOWORD(lParam);
		sy = HIWORD(lParam);

		for (int i = 0; i < myvec_xy.size(); i++)
		{
			myvec_xy[i].x =myvec_copy[i].x* kxy_setka;
			myvec_xy[i].y = myvec_copy[i].y* kxy_setka;
		}
		break;
	case WM_PAINT:///////////////////////////////////////////////////////////////////////////
		hdc = BeginPaint(hWnd, &ps);
		transform(hdc);
		hpen_setk1 = CreatePen(PS_SOLID, 1, RGB(204, 204, 204));
		hpen_setk2 = CreatePen(PS_SOLID, 1, RGB(150, 150, 150));
		hpen_plot1 = CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
		hpen_black = CreatePen(PS_SOLID, 1, RGB(0, 0, 0));
		hFont1 = CreateFont(10, 0, 0, 0, 600, 0, 0, 0,
			DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, _T("Arial"));
		//рисуем сеточку
		SelectObject(hdc, hpen_setk1);

		x_edgelineL = (sx_center / h_setka) * h_setka;//**приведение типов -  координаты - расстояние ДО граница левая, от нее начинается рисование вертикальной сетки
		y_edgelineT = (sy_center / h_setka) * h_setka;//**приведение типов -  координаты - расстояние ДО граница верхняя, от нее начинается рисование горизонтальной сетки
		x_edgelineR = sx - sx_center;//граница правая - конец рисования - НЕ координаты - расстояние ДО граница правая
		y_edgelineB = sy - sy_center - 1;//граница нихняя - конец рисования - НЕ координаты - расстояние ДО граница нижняя
		for (int ix = -x_edgelineL; ix < x_edgelineR; ix += h_setka) {
			MoveToEx(hdc, ix, -y_edgelineB, NULL);
			LineTo(hdc, ix, y_edgelineT);
		}
		for (int iy = -y_edgelineB; iy < y_edgelineT; iy += h_setka) {
			MoveToEx(hdc, -x_edgelineL, iy, NULL);
			LineTo(hdc, x_edgelineR, iy);
		}
		//рисуем большие клетки 
		SelectObject(hdc, hpen_setk2);
		x_edgelineL = ((x_edgelineL / h5_setka)+1) * h5_setka;//переходим в рисование больших квадратов и чисел
		y_edgelineB = ((y_edgelineB / h5_setka)+1) * h5_setka;
		for (int ix = -x_edgelineL; ix < x_edgelineR; ix += h5_setka) {
			MoveToEx(hdc, ix, -y_edgelineB, NULL);
			LineTo(hdc, ix, y_edgelineT);
		}
		for (int iy = -y_edgelineB; iy < y_edgelineT; iy += h5_setka) {
			MoveToEx(hdc, -x_edgelineL, iy, NULL);
			LineTo(hdc, x_edgelineR, iy);
		}
		//рисуем оси координат
		SelectObject(hdc, hpen_black);
		MoveToEx(hdc, 0, y_edgelineT, NULL);
		LineTo(hdc, 0, -y_edgelineB);
		MoveToEx(hdc, -x_edgelineL, 0, NULL);
		LineTo(hdc, x_edgelineR, 0);
		//рисуем числa
		SelectObject(hdc, hFont1);
		SetTextAlign(hdc, TA_TOP | TA_CENTER);
		//////////////////////////////////////////////////////////////////////
		ux = -u5_setka * x_edgelineL / h5_setka;//уходим в отрицательное крайнее значение
		uy = -u5_setka * y_edgelineB / h5_setka;
		xr = sx - sx_center;
		xl = -sx_center;
		yt = sy_center;
		yb = -(sy - sy_center);


		zerocount = 0;
		if (u5_setka < 1)zerocount = abs(round(log10(u5_setka)))+1;
		for (int ix = -x_edgelineL ; ix < x_edgelineR; ix += h5_setka) {
			_stprintf(s, L"%.*lf", zerocount, ux);
			TextOut(hdc, ix, yt -10, s, _tcslen(s));
			MoveToEx(hdc, ix, yt - 10, NULL);
			LineTo(hdc, ix, yt + 10);

			TextOut(hdc, ix, yb + 30, s, _tcslen(s));
			MoveToEx(hdc, ix, yb - 10, NULL);
			LineTo(hdc, ix, yb + 10);

			TextOut(hdc, ix, - 10, s, _tcslen(s));
			MoveToEx(hdc, ix, -10, NULL);
			LineTo(hdc, ix, 10);
			ux += u5_setka;
		}
		SetTextAlign(hdc, TA_LEFT);
		for (int iy = -y_edgelineB; iy < y_edgelineT; iy += h5_setka) {
			_stprintf(s, L"%.*lf", zerocount, uy);
			TextOut(hdc, xl+15, iy + 5, s, _tcslen(s));
			MoveToEx(hdc,xl+ 10, iy, NULL);
			LineTo(hdc,xl -10, iy);

			TextOut(hdc,xr - 30, iy + 5, s, _tcslen(s));
			MoveToEx(hdc, xr + 10, iy, NULL);
			LineTo(hdc, xr -10, iy);

			TextOut(hdc, 15, iy + 5, s, _tcslen(s));
			MoveToEx(hdc, 10, iy, NULL);
			LineTo(hdc, -10, iy);
			uy += u5_setka;

		}
		//рисуем график
		//т.к. график рисуется лишь по пикселам, хотя надо будет потом произвести перестройку в логических координатах
		//х = количество пикселов, соотв. положению х на нормальной системе координат
		if (!myvec_xy.empty())
		{
			myGraphics = new Graphics(hdc);
			myGraphics->SetSmoothingMode(SmoothingModeAntiAlias);
			myPen = new Pen(Color(1000, 255, 0, 0), 2);
			for (int i = 1; i < myvec_xy.size(); i++)
			{
				myGraphics->DrawLine(myPen, (int)(myvec_xy[i - 1].x), (int)(myvec_xy[i - 1].y), (int)(myvec_xy[i].x ), (int)(myvec_xy[i].y));
			}
			delete myGraphics;
			delete myPen;
		}


		EndPaint(hWnd, &ps);
		break;
	case WM_DESTROY:
		//DeleteObject(hpen_setk1);
		//DeleteObject(hpen_setk2);
		//DeleteObject(hpen_black);
		//DeleteObject(hpen_plot1);
		//DeleteObject(hFont1);
		PostQuitMessage(0);
		break;
	default: return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}

void transform(HDC& hdc)
{
	SetMapMode(hdc, MM_ANISOTROPIC);
	SetWindowExtEx(hdc, sx, -sy, NULL);//установка  логические размеры - в пикселах - влияет на размеры текста и проч "писельные" переменные
	//У.Е. (логические границы) = (реальные границы[пикс])/(указанное число x_lokal,y_lokal)
	SetViewportExtEx(hdc, sx, sy, NULL);//ОБЛАСТЬ ВЫВОДА  -  физические размеры области вывода в пикселах
	//= локальные поделить на указанные - в у.е.
	SetViewportOrgEx(hdc, sx_center, sy_center, NULL);
}

